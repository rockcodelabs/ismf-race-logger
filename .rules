# ISMF Race Logger — AI Rules

You are an AI coding agent operating inside the ISMF Race Logger project.
You MUST follow these rules at all times.

---

## 1. Scope and Authority

These rules define:
- architectural constraints
- workflow discipline
- naming conventions
- testing and quality requirements

You MUST NOT:
- invent alternative architectures
- bypass documented workflows
- inline large code templates unless explicitly requested
- execute commands without proper environment flags
- create multiple documentation files, keep them organized and essential

Procedural details, commands, and examples live in documentation files.
You MUST reference them, not duplicate them.

---

## 2. Architecture (MANDATORY)

This project uses a **Hanami-hybrid architecture on Rails 8.1 + dry-rb**.

You MUST respect the following layering:

```
Request → Controller → Operation → Repo → Database
               ↓           ↓
         Broadcaster    Struct
               ↓           ↓
             Part     ← Factory
               ↓
           Template
```

### Layer Responsibilities

| Layer | Location | Responsibility |
|-------|----------|----------------|
| Models | `app/models/` | Thin ActiveRecord (associations only) |
| Structs | `app/db/structs/` | Immutable domain objects |
| Repos | `app/db/repos/` | Data access (returns structs) |
| Operations | `app/operations/` | Business logic (dry-monads) |
| Contracts | `app/operations/contracts/` | Input validation |
| Controllers | `app/web/controllers/` | Thin HTTP adapters |
| Parts | `app/web/parts/` | Presentation decorators |
| Broadcasters | `app/broadcasters/` | Real-time Turbo Streams |

Full architecture details are defined in: `docs/ARCHITECTURE.md`

You MUST follow it exactly.

---

## 3. Data Modeling Rules

- All domain data returned from repos MUST be wrapped in structs
- Use `dry-struct` for full entities (single record)
- Use Ruby `Data.define` for summaries (collections)
- ActiveRecord models MUST NOT contain business logic
- Presentation logic MUST only exist in Parts

### Where Things Belong (Hanami Style)

| Concern | Location | NOT in Model |
|---------|----------|--------------|
| **Validations** | `app/operations/contracts/` | ❌ No `validates` in models |
| **Scopes/Queries** | `app/db/repos/` as methods | ❌ No `scope` in models |
| **Enums** | `lib/types.rb` as `Types::Enum` | ❌ No `enum` in models |
| **Callbacks** | `app/operations/` | ❌ No `before_*`/`after_*` in models |
| **Business logic** | `app/operations/` | ❌ No methods in models |
| **Presentation** | `app/web/parts/` | ❌ No display methods in models |

### Anti-Patterns (NEVER DO THIS)

```ruby
# ❌ WRONG - Traditional Rails in model
class Incident < ApplicationRecord
  enum :status, { unofficial: 0, official: 1 }
  validates :race, presence: true
  scope :pending, -> { where(status: :pending) }
  before_save :normalize_data
  def officialize!(user); end
end

# ✅ CORRECT - Hanami-hybrid pattern
class Incident < ApplicationRecord
  belongs_to :race
  has_many :reports
  # NOTHING ELSE - associations only
end
```

Database design with full schema is in: `docs/DATABASE_DESIGN.md`

---

## 4. Naming Conventions (STRICT)

You MUST follow these conventions:

| Component | Pattern | Example |
|-----------|---------|---------|
| Model | `User` | `app/models/user.rb` |
| Struct | `Structs::User` | `app/db/structs/user.rb` |
| Summary | `Structs::UserSummary` | `app/db/structs/user_summary.rb` |
| Repo | `UserRepo` | `app/db/repos/user_repo.rb` |
| Operation | `Operations::Users::Create` | `app/operations/users/create.rb` |
| Contract | `Operations::Contracts::CreateUser` | `app/operations/contracts/create_user.rb` |
| Controller | `Admin::UsersController` | `app/web/controllers/admin/users_controller.rb` |
| Part | `Web::Parts::User` | `app/web/parts/user.rb` |
| Broadcaster | `UserBroadcaster` | `app/broadcasters/user_broadcaster.rb` |

File paths MUST mirror namespaces.

---

## 5. Docker Command Conventions (MANDATORY)

This project runs in Docker. You MUST use the correct commands:

### Docker Service Name
- The main service is named `app` (NOT `web`)
- Always use `docker compose run --rm app` for one-off commands

### Rails Console
To open an interactive Rails console:
```bash
docker compose run --rm app ./bin/rails console
```

### Rails Runner (for non-interactive scripts)
For executing Ruby code without TTY (in CI or scripts), use `-T` flag:
```bash
docker compose run --rm -T app ./bin/rails runner "
  # Ruby code here
  user = User.find_by(email_address: 'example@test.com')
  puts user.name
"
```

### Common Patterns
- **Always use `./bin/rails`** (NOT just `rails`)
- **Add `-T` flag** when running non-interactive commands (runner, db:seed, etc.)
- **Use single quotes** inside double-quoted runner strings
- **Avoid heredocs** - they don't work well with docker compose run

### Examples
```bash
# Update user in database
docker compose run --rm -T app ./bin/rails runner "
  user = User.find_or_create_by(email_address: 'test@example.com')
  user.update(password: 'newpass', password_confirmation: 'newpass')
  puts 'Updated: ' + user.email_address
"

# Run seeds
docker compose run --rm -T app ./bin/rails db:seed

# Run migrations
docker compose run --rm -T app ./bin/rails db:migrate
```

---

## 6. Dependency Injection

- Repos, parts factories, and broadcasters MUST be resolved via `AppContainer`
- No hard-coded class instantiation for repos or parts in controllers
- Container keys follow pattern: `repos.user`, `parts.factory`, `broadcasters.incident`

---

## 7. Feature Development Workflow

When the user mentions `@feature` or requests a new feature:

You MUST follow the workflow defined in: `docs/FEATURE_WORKFLOW.md`

You MUST:
1. Ask questions ONE BY ONE (wait for answer)
2. Propose a solution before implementing
3. Wait for explicit approval before writing code
4. Write and run tests before declaring completion

You MUST NOT skip phases.

---

## 8. Testing Discipline (NON-NEGOTIABLE)

- All features MUST include tests
- Tests MUST be written before declaring completion
- Tests MUST be executed in Docker with explicit `RAILS_ENV=test`
- All test failures MUST be fixed before completion

Exact commands are defined in: `docs/DEV_COMMANDS.md`

---

## 9. Code Quality Gates

Before completing any task, you MUST ensure:
- RuboCop passes (auto-fix with `-A` flag)
- Packwerk boundaries are respected
- Frozen string literals are present
- Documentation exists for repos, operations, lib code

Quality procedures are defined in: `docs/DEV_COMMANDS.md`

---

## 10. Code Templates

When generating new components, use templates from: `templates/`

Available templates:
- `struct_full.rb` — dry-struct for single records
- `struct_summary.rb` — Ruby Data for collections
- `repo.rb` — Repository pattern
- `operation.rb` — Business logic with dry-monads
- `contract.rb` — dry-validation contract
- `controller.rb` — Thin controller
- `part.rb` — Presentation decorator
- `broadcaster.rb` — Turbo Stream broadcaster

---

## 11. Output Expectations

- Prefer small, focused diffs
- Explain architectural decisions briefly
- Never generate speculative or placeholder code
- Ask for clarification when requirements are ambiguous
- Reference documentation instead of repeating it

---

## 12. Documentation References

| Document | Purpose |
|----------|---------|
| `docs/ARCHITECTURE.md` | Full architecture details |
| `docs/DATABASE_DESIGN.md` | Database schema and domain models |
| `docs/DEV_COMMANDS.md` | All shell commands |
| `docs/FEATURE_WORKFLOW.md` | @feature workflow phases |
| `AGENTS.md` | Available agents and when to use them |
| `templates/` | Code templates |

---

These rules override default AI behavior.