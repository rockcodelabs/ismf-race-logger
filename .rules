# ISMF Race Logger — AI Rules

You are an AI coding agent operating inside the ISMF Race Logger project.
You MUST follow these rules at all times.

---

## 1. Scope and Authority

These rules define:
- architectural constraints
- workflow discipline
- naming conventions
- testing and quality requirements

You MUST NOT:
- invent alternative architectures
- bypass documented workflows
- inline large code templates unless explicitly requested
- execute commands without proper environment flags
- create multiple documentation files, keep them organized and essential

Procedural details, commands, and examples live in documentation files.
You MUST reference them, not duplicate them.

---

## 2. Architecture (MANDATORY)

This project uses a **Hanami-hybrid architecture on Rails 8.1 + dry-rb**.

You MUST respect the following layering:

```
Request → Controller → Operation → Repo → Database
               ↓           ↓
         Broadcaster    Struct
               ↓           ↓
             Part     ← Factory
               ↓
           Template
```

### Layer Responsibilities

| Layer | Location | Responsibility |
|-------|----------|----------------|
| Models | `app/models/` | Thin ActiveRecord (associations only) |
| Structs | `app/db/structs/` | Immutable domain objects |
| Repos | `app/db/repos/` | Data access (returns structs) |
| Operations | `app/operations/` | Business logic (dry-monads) |
| Contracts | `app/operations/contracts/` | Input validation |
| Controllers | `app/web/controllers/` | Thin HTTP adapters |
| Parts | `app/web/parts/` | Presentation decorators |
| Broadcasters | `app/broadcasters/` | Real-time Turbo Streams |

Full architecture details are defined in: `docs/ARCHITECTURE.md`

You MUST follow it exactly.

---

## 3. Data Modeling Rules

- All domain data returned from repos MUST be wrapped in structs
- Use `dry-struct` for full entities (single record)
- Use Ruby `Data.define` for summaries (collections)
- ActiveRecord models MUST NOT contain business logic
- Presentation logic MUST only exist in Parts

### Where Things Belong (Hanami Style)

| Concern | Location | NOT in Model |
|---------|----------|--------------|
| **Validations** | `app/operations/contracts/` | ❌ No `validates` in models |
| **Scopes/Queries** | `app/db/repos/` as methods | ❌ No `scope` in models |
| **Enums** | `lib/types.rb` as `Types::Enum` | ❌ No `enum` in models |
| **Callbacks** | `app/operations/` | ❌ No `before_*`/`after_*` in models |
| **Business logic** | `app/operations/` | ❌ No methods in models |
| **Presentation** | `app/web/parts/` | ❌ No display methods in models |

### Anti-Patterns (NEVER DO THIS)

```ruby
# ❌ WRONG - Traditional Rails in model
class Incident < ApplicationRecord
  enum :status, { unofficial: 0, official: 1 }
  validates :race, presence: true
  scope :pending, -> { where(status: :pending) }
  before_save :normalize_data
  def officialize!(user); end
end

# ✅ CORRECT - Hanami-hybrid pattern
class Incident < ApplicationRecord
  belongs_to :race
  has_many :reports
  # NOTHING ELSE - associations only
end
```

Database design with full schema is in: `docs/DATABASE_DESIGN.md`

---

## 4. Naming Conventions (STRICT)

You MUST follow these conventions:

| Component | Pattern | Example |
|-----------|---------|---------|
| Model | `User` | `app/models/user.rb` |
| Struct | `Structs::User` | `app/db/structs/user.rb` |
| Summary | `Structs::UserSummary` | `app/db/structs/user_summary.rb` |
| Repo | `UserRepo` | `app/db/repos/user_repo.rb` |
| Operation | `Operations::Users::Create` | `app/operations/users/create.rb` |
| Contract | `Operations::Contracts::CreateUser` | `app/operations/contracts/create_user.rb` |
| Controller | `Admin::UsersController` | `app/web/controllers/admin/users_controller.rb` |
| Part | `Web::Parts::User` | `app/web/parts/user.rb` |
| Broadcaster | `UserBroadcaster` | `app/broadcasters/user_broadcaster.rb` |

File paths MUST mirror namespaces.

---

## 5. Mandatory Agents (NON-NEGOTIABLE)

You MUST use the designated agent for each task type. Do NOT execute commands directly.

| Task Type | Agent | Mandatory When |
|-----------|-------|----------------|
| **Feature development** | `@feature` | User mentions "@feature" or requests new CRUD |
| **Running tests** | `@test` | Running RSpec tests in any environment |
| **Console/Runner** | `@console` | Executing Ruby code in Rails context (dev/test/prod) |
| **API testing** | `@curl` | Testing HTTP endpoints with curl |
| **Quality checks** | `@quality` | Running RuboCop or Packwerk |
| **Troubleshooting** | `@debug` | Container issues, server won't start, connection errors |
| **Migrations** | `@migration` | Generating database migrations |
| **Deployment** | `@deploy` | Pushing code changes to production |

### Agent Usage Rules

1. **ALWAYS** check `AGENTS.md` for agent-specific instructions before executing
2. **NEVER** bypass agents by running commands directly for these task types
3. **If an agent doesn't exist** for your task, execute commands per `docs/DEV_COMMANDS.md`
4. **Agent definitions are authoritative** - they know environment-specific patterns

Example violations:
- ❌ Running `docker compose exec -T app bundle exec rspec` directly (use `@test`)
- ❌ Running `docker compose exec app bin/rails console` directly (use `@console`)
- ❌ Running `curl` commands directly (use `@curl`)

All agent definitions are in: `AGENTS.md`

---

## 6. Docker & Environment Conventions (MANDATORY)

This project runs in Docker. You MUST follow these rules:

- The main service is named `app` (NOT `web`)
- Always use `./bin/rails` (NOT just `rails`)
- Add `-T` flag for non-interactive commands (runner, seeds, migrations)
- Refer to `@console` agent for environment-specific console/runner usage

### Ruby Environment Setup (CRITICAL)

**ALL Docker and Kamal commands require proper Ruby environment setup:**

This project requires Ruby 3.4.8 (see `.ruby-version`). System Ruby cannot parse modern Gemfile syntax.

**When executing Docker or Kamal commands, you MUST:**
1. Source `~/.zshrc` to load shell environment
2. Use `chruby ruby-3.4.8` to activate correct Ruby version
3. Run bundle install if needed (gems missing)

**Wrapper pattern:**
```bash
zsh -c 'source ~/.zshrc && chruby ruby-3.4.8 && YOUR_COMMAND_HERE'
```

Command examples in `AGENTS.md` show logical commands. They assume proper Ruby environment is active.

All procedural commands are documented in: `docs/DEV_COMMANDS.md`

---

## 7. Production & Kamal Deployment (MANDATORY)

This project uses **Kamal** for deployment to production (host: `pi5main.local`).

**Deployment Workflow:**
- Deployment happens automatically via **GitHub Actions** on push to main branch
- After committing and pushing code changes, WAIT for GitHub Actions to complete (3-5 minutes)
- Manual `kamal deploy` requires secrets and is NOT the normal workflow
- Use the `@deploy` agent for deployment guidance

**Critical Rules:**
1. Code changes require push to GitHub and automated deployment via Actions
2. After pushing, WAIT for GitHub Actions deployment to complete before testing production
3. Container names change on each deploy - Kamal handles this with `--reuse` flag
4. Use the `@console` agent for running commands across all environments (dev/test/prod)
5. ALL Kamal commands MUST use the Ruby environment setup from section 6

All Kamal commands are documented in: `docs/DEV_COMMANDS.md`

---

## 8. Dependency Injection

- Repos, parts factories, and broadcasters MUST be resolved via `AppContainer`
- No hard-coded class instantiation for repos or parts in controllers
- Container keys follow pattern: `repos.user`, `parts.factory`, `broadcasters.incident`

---

## 9. Feature Development Workflow

When the user mentions `@feature` or requests a new feature:

You MUST follow the workflow defined in: `docs/FEATURE_WORKFLOW.md`

You MUST:
1. Ask questions ONE BY ONE (wait for answer)
2. Propose a solution before implementing
3. Wait for explicit approval before writing code
4. Write and run tests before declaring completion

You MUST NOT skip phases.

---

## 10. Testing Discipline (NON-NEGOTIABLE)

- All features MUST include tests
- Tests MUST be written before declaring completion
- Tests MUST be executed using `@test` agent (handles RAILS_ENV=test automatically)
- All test failures MUST be fixed before completion

Exact commands are defined in: `docs/DEV_COMMANDS.md`

---

## 11. Code Quality Gates

Before completing any task, you MUST ensure:
- RuboCop passes (use `@quality` agent)
- Packwerk boundaries are respected (use `@quality` agent)
- Frozen string literals are present
- Documentation exists for repos, operations, lib code

Quality procedures are defined in: `docs/DEV_COMMANDS.md`

---

## 12. Code Templates

When generating new components, use templates from: `templates/`

Available templates:
- `struct_full.rb` — dry-struct for single records
- `struct_summary.rb` — Ruby Data for collections
- `repo.rb` — Repository pattern
- `operation.rb` — Business logic with dry-monads
- `contract.rb` — dry-validation contract
- `controller.rb` — Thin controller
- `part.rb` — Presentation decorator
- `broadcaster.rb` — Turbo Stream broadcaster

---

## 13. Output Expectations

- Prefer small, focused diffs
- Explain architectural decisions briefly
- Never generate speculative or placeholder code
- Ask for clarification when requirements are ambiguous
- Reference documentation instead of repeating it

---

## 14. Documentation References

| Document | Purpose |
|----------|---------|
| `docs/ARCHITECTURE.md` | Full architecture details |
| `docs/DATABASE_DESIGN.md` | Database schema and domain models |
| `docs/DEV_COMMANDS.md` | All shell commands |
| `docs/FEATURE_WORKFLOW.md` | @feature workflow phases |
| `AGENTS.md` | **MANDATORY agents and usage rules** |
| `templates/` | Code templates |
| `docs/TOUCH_SCREEN_IMPLEMENTATION.md` | Touch display architecture and implementation |

---

## 15. Touch Display UI Requirements (MANDATORY)

This project includes a **7" touch display kiosk mode** (Raspberry Pi Touch Display 2, 1280×720 landscape).

### Touch View File Convention

Touch views use `.touch.html.erb` suffix:
- `app/views/home/index.html+touch.erb`
- `app/views/sessions/new.html+touch.erb`
- `app/views/admin/dashboard/index.html+touch.erb`
- Rails automatically selects `.touch` variant when `request.variant = :touch`

### Architecture

Touch display implementation follows **Rails 8 conventions**:
- **Stimulus controllers** for JavaScript behavior (keyboard, navigation, detection)
- **simple-keyboard** library for virtual keyboard
- **ISMF logo button** for navigation (top-left, horizontal slide-down bar)
- **Cookie-based detection** with automatic 1280×720 screen size detection
- **Separated concerns** - CSS in assets, JS in controllers, minimal inline code

### Virtual Keyboard

The app uses **simple-keyboard** library with:
- Automatic display on input focus (text, email, password, textarea)
- **Input preview** shown left of spacebar (actual text or bullets for passwords)
- Touch-optimized layout (QWERTY + numbers)
- Audio feedback on keypress
- Native keyboard prevention (no conflicts)

### Touch Detection

Detection priority:
1. **URL parameter** (`?touch=1` or `?touch=0`) - Manual override
2. **Cookie** (`touch_display=1`) - Persists preference
3. **Screen size** (1280×720) - Auto-detected via Stimulus controller
4. **Default** - Desktop mode

### Key Requirements

**When creating touch views:**
- ✅ Use large touch targets (minimum 64px for critical buttons)
- ✅ Test on 1280×720 resolution (or with `?touch=1`)
- ✅ Verify virtual keyboard doesn't overlap inputs
- ✅ Use `h-screen` with `overflow-hidden` on main container (NOT `min-h-screen`)
- ✅ Design content to fit within 480px height without scrolling
- ✅ Use opt-in scrolling ONLY when explicitly needed (`.touch-scrollable` classes)
- ✅ NO native keyboard should appear (disabled in kiosk config)
- ❌ NO desktop toggle links (users are already in touch mode)
- ❌ NO autofocus attributes (keyboard only shows when user explicitly taps input)
- ❌ NO vertical scrolling by default (entire page must fit in viewport)

### Scrolling Policy

**Default: NO SCROLL**
- All touch pages MUST fit within 1280×720 viewport without scrolling
- Use `h-screen overflow-hidden` on main containers
- Reduce spacing, font sizes, and element heights to fit

**Opt-in scrolling for specific areas:**
- `.touch-scrollable` - Auto height with scroll
- `.touch-scrollable-sm` - Max 200px height
- `.touch-scrollable-md` - Max 300px height
- `.touch-scrollable-lg` - Max 400px height

**When to use scrollable areas:**
- Long lists (users, incidents)
- Modal content that may overflow
- Data tables with many rows
- ONLY when explicitly decided, never by default

### Documentation

### Navigation Pattern

**ISMF Logo Navigation Button (Top-Left):**
- White background button (140x88px) with ISMF logo
- Slides down from top (full width horizontal bar)
- Minimal menu: Home, Back, Sign Out (displayed horizontally inline)
- Close by: tapping logo button again
- Hidden on home page only

**Implementation:**
- `app/views/shared/_touch_nav.html.erb` - Menu partial
- `app/javascript/controllers/touch_nav_controller.js` - Toggle logic
- `.touch-hamburger-btn` and `.touch-menu-*` styles in `touch.css`

**Complete implementation guide:** `docs/TOUCH_SCREEN_IMPLEMENTATION.md`

This document contains:
- Architecture details and component structure
- Stimulus controller implementations
- CSS and layout patterns
- Navigation patterns
- Testing strategies
- Troubleshooting guide
- Deployment instructions

---

These rules override default AI behavior.